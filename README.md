# Simple_P2P_chatsystem (C & Go Comparison)
このプロジェクトは、ネットワークプログラミングの基礎であるUDP通信を題材に、C言語での低レイヤー実装（Standard UDP / Raw Socket）と、Go言語での実装を比較・学習することを目的としています。

## 1.C言語による2つのアプローチの比較
C言語版では、OSの機能をどの程度利用するかによって2種類の実装を行いました。
| 比較項目 | Standard UDP (`udp_chat.c`) | Raw Socket (`raw_chat.c`) |
| :--- | :--- | :--- |
| **抽象度** | **高い**（OS がヘッダーを自動処理） | **低い**（ヘッダーを自力で構築） |
| **主な処理** | `sendto` / `recvfrom` の単純な呼出 | IP/UDP ヘッダー構築、チェックサム計算 |
| **実行権限** | 一般ユーザー権限 | **管理者権限 (sudo)** が必須 |
| **実装の難易度** | 中（ソケットプログラミングの基礎） | 高（パケット構造の深い理解が必要） |
| **I/O 多重化** | `epoll` による多重化 | `epoll` による多重化 |

## 2.Go言語での実現
C 言語との違いGo言語版（go_chat.go）では、C言語での複雑な実装が大幅に簡略化されています。
### 並行処理のパラダイムシフト
#### C言語:epoll_waitを含むイベントループを自分で管理し、発生したイベントを条件分岐でさばきます。
#### Go言語: 受信処理をGoroutine (go func()) として切り出します。Goのランタイムが内部的にepoll等を管理するため、コード上では「入力待ち」と「受信待ち」を独立した直列の処理として記述できます。
###実装の簡潔性
#### Goのnetパッケージは、アドレス解決（ResolveUDPAddr）やソケットのバインドを非常に高い抽象度で提供します。C言語で必要だった構造体の初期化やバイトオーダーの変換処理が、わずか数行に凝縮されています。

## 3.実行コマンド
### 3.1 udp_chat.c
① cd chatsystem_C
② make start
③ make login-node1
④ gcc udp_chat.c -o udp_chat
⑤ ./udp_chat 10.100.0.20
⑥ (別画面で①の後) make login-node2 
⑦　./udp_chat 10.100.0.10
⑧ チャット開始

### 3.2 raw_chat.c
① cd chatsystem_C
② make start
③ make login-node1
④ gcc raw_chat.c -o raw_chat
⑤ sudo ./raw_chat 10.100.0.10 10.100.0.20
⑥ (別画面で①の後) make login-node2 
⑦　./raw_chat 10.100.0.20 10.100.0.10
⑧ チャット開始

### 3.3 go_chat.go
① cd chatsystem_Go
② make start
③ make login-node1
④ go run go_chat.go 10.100.0.20
⑤ (別画面で①の後) make login-node2 
⑥ go run go_chat.go 10.100.0.10
⑦ チャット開始

## 4.Go言語で実装するメリット・デメリット
C言語での低レイヤー実装と比較した際の、Go言語の評価です。
### メリット
#### 高い生産性と可読性
epoll周りの複雑なボイラープレートコードが不要になり、コード量が40％ほど削減できます。
#### メモリ安全性
固定長バッファの管理やオーバーフローの心配が、Goのスライスとガベージコレクションによって解消されます。
#### 標準ライブラリの強力さ
外部ライブラリを使わずに、安全かつ効率的なネットワーク処理が完結します。
### デメリット
#### 低レイヤーへのアクセスの制限
raw_chat.cで行ったような「IP ヘッダーを 1 ビット単位で操作する」といった処理は、標準ライブラリの範囲外となります。
#### ランタイムの隠蔽
epollやシステムコールがどのように呼ばれているかという「裏側の動き」が見えにくくなるため、学習目的では C言語の知識が補完的に必要です。
#### バイナリサイズ
実行環境に依存しない静的バイナリを作成できますが、ランタイムを含むため、C言語に比べるとサイズが大きくなります。

## 5.実装の様子

## 6.結論
このプロジェクトを通じて、「C言語でパケットの構造とOSのイベント通知の仕組みを学び、Go言語でそれらをいかに効率的かつ安全に抽象化してシステムを構築するか」 という、ネットワークプログラミングの深層からモダンな開発手法までの連続性を体験することができます。
